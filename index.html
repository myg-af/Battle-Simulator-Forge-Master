<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Battle Simulator Forge Master</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; background-color: #f0f0f0; }
.container { background: #fff; padding: 20px; border-radius: 10px; max-width: 600px; margin: auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
label { display: block; margin-top: 10px; }
input[type=number] { width: 60px; }
button { margin-top: 20px; padding: 10px 15px; font-size: 16px; }
.result { margin-top: 20px; background: #e0ffe0; padding: 10px; border-radius: 5px; }
.best-build { margin-top: 20px; background: #c0dfff; padding: 10px; border-radius: 5px; }
.canvas-container {
    display: flex;
    flex-wrap: wrap;          /* permet de passer à la ligne suivante */
    gap: 20px;                /* espace entre canvas */
    justify-content: center;  /* centre horizontalement */
    padding: 20px;
    background-color: #f8f8f8; /* léger fond pour différencier */
    width: 100%;              /* prend toute la largeur */
    box-sizing: border-box;
}

.canvas-container canvas {
    border-radius: 10px;
    background-color: #222;
}




</style>
</head>
<body>
<div class="container">
<h2>Battle Simulator Forge Master</h2>
</br>
<h3>General Settings</h3>
<label>Base Damage: <input type="number" id="damage" value="30000"></label>
<label>Base HP: <input type="number" id="hp" value="200000"></label>

<label>PvP HP multiplier: <input type="number" id="hpMultiplier" value="5"></label>
<label>Number of simulations:
    <input type="number" id="numSimulations" value="50" min="1" max="1000">
</label>

<label>Visible simulations:
    <input type="number" id="visibleSimulations" value="4" min="0" max="10">
</label>



</br>
<h3>Best Build Settings:</h3>

<label>Type of weapon:
    <select id="bestBuildWeaponType">
        <option value="Ranged" selected>Ranged</option>
        <option value="Melee">Melee</option>
    </select>
</label>

<label>Total number of sub-stats: <input type="number" id="bonusPoints" value="12"></label>







</br>
<h3>Player Settings:</h3>
<label>Type of weapon: 
    <select id="weaponType">
        <option value="Ranged" selected>Ranged</option>
        <option value="Melee">Melee</option>
    </select>
</label>
<h4>Distribute your sub-stats:</h4>
<label>Attack Speed (+40% per sub-stat): <input type="number" id="bonusAttackSpeed" value="2"></label>
<label>Double Chance (+40% per sub-stat): <input type="number" id="bonusDoubleHit" value="2"></label>
<label>Lifesteal (+20% per sub-stat): <input type="number" id="bonusLifeSteal" value="2"></label>
<label>Critical Chance (+12% per sub-stat): <input type="number" id="bonusCritChance" value="2"></label>
<label>Critical Damage (+100% per sub-stat): <input type="number" id="bonusCritDamage" value="2"></label>
<label>Health Regen (+6% per sub-stat): <input type="number" id="bonusRegen" value="1"></label>
<label>Damage (+15% per sub-stat): <input type="number" id="bonusDamage" value="1"></label>
<label>Melee Damage (+50% per sub-stat): <input type="number" id="bonusMeleeDamage" value="0"></label>
<label>Block Chance (+5% per sub-stat): <input type="number" id="bonusBlock" value="0"></label>
<label>HP (+15% per sub-stat): <input type="number" id="bonusHP" value="0"></label>

<button onclick="calculate()">Calculate and Start Battle</button>
<div class="result" id="result"></div>
<div class="best-build" id="bestBuild"></div>
</div>


<div id="battleScores" style="
    margin: 20px auto;
    padding: 12px;
    max-width: 600px;
    text-align: center;
    font-weight: bold;
    font-size: 16px;
    background: #fff3cd;
    border-radius: 8px;
    box-shadow: 0 0 6px rgba(0,0,0,0.15);
">
    Player Wins: 0 | Best Build Wins: 0 | Player Winrate: 0%
</div>



<div class="canvas-container" id="canvasContainer"></div>


<script>

function updateURL() {
const fields = [
    'damage', 'hp', 'hpMultiplier', 'bonusPoints',
    'bonusAttackSpeed', 'bonusDoubleHit', 'bonusLifeSteal',
    'bonusCritChance', 'bonusCritDamage', 'bonusRegen', 'bonusDamage',
    'bonusMeleeDamage', 'bonusBlock',
    'weaponType',
    'bestBuildWeaponType','numSimulations','visibleSimulations',
];



    const params = new URLSearchParams();

    fields.forEach(id => {
        params.set(id, document.getElementById(id).value);
    });

    const newURL = window.location.origin + window.location.pathname + '?' + params.toString();
    window.history.replaceState({}, '', newURL); // Met à jour l’URL sans recharger la page
}

function loadFromURL() {
    const params = new URLSearchParams(window.location.search);
const fields = [
    'damage', 'hp', 'hpMultiplier', 'bonusPoints',
    'bonusAttackSpeed', 'bonusDoubleHit', 'bonusLifeSteal',
    'bonusCritChance', 'bonusCritDamage', 'bonusRegen', 'bonusDamage',
    'bonusMeleeDamage', 'bonusBlock',
    'weaponType',
    'bestBuildWeaponType','numSimulations','visibleSimulations',
];


    fields.forEach(id => {
        if(params.has(id)) {
			let value = params.get(id);

			if (id === 'numSimulations') {
				value = Math.min(parseInt(value) || 1, MAX_SIMULATIONS);
			}

			if (id === 'bonusPoints') {
				value = Math.min(parseInt(value) || 0, MAX_TOTAL_SUBSTATS);
			}
			if (id === 'visibleSimulations') {
				value = Math.min(Math.max(parseInt(value) || 0, 0), MAX_VISIBLE_SIMULATIONS);
			}





			document.getElementById(id).value = value;

        }
    });
}

const MELEE_SPEED = 2; // pixels par frame
const MELEE_MIN_DISTANCE = 50; // distance minimale entre les personnages Melee
const MELEE_APPROACH_TIME = 3.5; // secondes pour atteindre un adversaire à distance

const MAX_SIMULATIONS = 1000;
const MAX_TOTAL_SUBSTATS = 25;
const MAX_VISIBLE_SIMULATIONS = 10;
let simulationId = 0;



function calculate() {
	simulationId++;
	
	
	// --- GARDE-FOUS GLOBAUX ---

	// Limite simulations
	let numSimulationsInput = document.getElementById('numSimulations');
	let numSimulations = parseInt(numSimulationsInput.value) || 1;

	// Limite simulations visibles
	let visibleSimulationsInput = document.getElementById('visibleSimulations');
	let visibleSimulations = parseInt(visibleSimulationsInput.value) || 0;

	if (visibleSimulations > MAX_VISIBLE_SIMULATIONS) {
		visibleSimulations = MAX_VISIBLE_SIMULATIONS;
		visibleSimulationsInput.value = MAX_VISIBLE_SIMULATIONS;
	}

	if (visibleSimulations < 0) {
		visibleSimulations = 0;
		visibleSimulationsInput.value = 0;
	}



	if (numSimulations > MAX_SIMULATIONS) {
		numSimulations = MAX_SIMULATIONS;
		numSimulationsInput.value = MAX_SIMULATIONS;
	}

	// Limite sub-stats best build
	let bonusPointsInput = document.getElementById('bonusPoints');
	let totalBonusPoints = parseInt(bonusPointsInput.value) || 0;

	if (totalBonusPoints > MAX_TOTAL_SUBSTATS) {
		totalBonusPoints = MAX_TOTAL_SUBSTATS;
		bonusPointsInput.value = MAX_TOTAL_SUBSTATS;
	}

	
	
	document.getElementById('battleScores').innerText =
    'Player Wins: 0 | Best Build Wins: 0 | Player Winrate: 0%';
	const currentSimulationId = simulationId;
    const BASE_ATTACKS_PER_SECOND = 1 / 1.7;

    let damage = parseFloat(document.getElementById('damage').value);
    let hp = parseFloat(document.getElementById('hp').value);
	let weaponType = document.getElementById('weaponType').value; // "Ranged" ou "Melee"
    let hpMultiplier = parseFloat(document.getElementById('hpMultiplier').value) || 1;
	let bestBuildWeaponType = document.getElementById('bestBuildWeaponType').value; // Auto / Ranged / Melee

	
	
    let bonusAttackSpeed = parseInt(document.getElementById('bonusAttackSpeed').value) || 0;
    let bonusDoubleHit = parseInt(document.getElementById('bonusDoubleHit').value) || 0;
    let bonusLifeSteal = parseInt(document.getElementById('bonusLifeSteal').value) || 0;
    let bonusCritChance = parseInt(document.getElementById('bonusCritChance').value) || 0;
    let bonusCritDamage = parseInt(document.getElementById('bonusCritDamage').value) || 0;
    let bonusRegen = parseInt(document.getElementById('bonusRegen').value) || 0;
    let bonusDamage = parseInt(document.getElementById('bonusDamage').value) || 0;
	let bonusMeleeDamage = parseInt(document.getElementById('bonusMeleeDamage').value) || 0;
	let bonusBlock = parseInt(document.getElementById('bonusBlock').value) || 0;
	let bonusHP = parseInt(document.getElementById('bonusHP').value) || 0;


// --- Caps maximum par sous-stat ---
const CAPS = {
    attackSpeed: 480,
    doubleHit: 1,        // 100%
    lifeSteal: 2.4,      // 240%
    critChance: 1,       // 100%
    critDamage: 12,      // 1200%
    regen: 0.72,         // 72%
    damage: 3.6,         // 360%
    meleeDamage: 6,      // 600%
    block: 0.6           // 60%
};

// --- Limite par bonus à 12 points ---
function capPoints(points, maxPoints = 12){
    return Math.min(points, maxPoints);
}

bonusAttackSpeed = capPoints(bonusAttackSpeed);
bonusDoubleHit = capPoints(bonusDoubleHit);
bonusLifeSteal = capPoints(bonusLifeSteal);
bonusCritChance = capPoints(bonusCritChance);
bonusCritDamage = capPoints(bonusCritDamage);
bonusRegen = capPoints(bonusRegen);
bonusDamage = capPoints(bonusDamage);
bonusMeleeDamage = capPoints(bonusMeleeDamage);
bonusBlock = capPoints(bonusBlock);
bonusHP = capPoints(bonusHP);

// --- Calcul avec cap ---
let attackSpeed = Math.min(0.4 * bonusAttackSpeed * 100, CAPS.attackSpeed);
let doubleHitChance = Math.min(0.4 * bonusDoubleHit, CAPS.doubleHit);
let lifeSteal = Math.min(0.2 * bonusLifeSteal, CAPS.lifeSteal);
let critChance = Math.min(0.12 * bonusCritChance, CAPS.critChance);
let critDamageBonus = Math.min(1.2 + 1.0 * bonusCritDamage, CAPS.critDamage);
let regen = Math.min(0.06 * bonusRegen, CAPS.regen);
let damageBonus = Math.min(1 + 0.15 * bonusDamage, CAPS.damage);
let meleeDamageBonus = 1;
if(weaponType === "Melee" && bonusMeleeDamage > 0){
    meleeDamageBonus = Math.min(1 + 0.5 * bonusMeleeDamage, CAPS.meleeDamage);
}
let blockChance = Math.min(0.05 * bonusBlock, CAPS.block);

// HP séparé
let hpBonusMultiplier = 1 + 0.15 * bonusHP; // seulement HP max
let maxHP = hp * hpBonusMultiplier * hpMultiplier;


function computeScore(damage, atkSpeed, doubleHit, critChance, critDamage, lifeSteal, regen, maxHp, dmgBonus, meleeBonus = 1, blockChance = 0) {
    // DPS
    let dpsSingle = damage * dmgBonus * meleeBonus * (1 + critChance * (critDamage - 1));
    let dpsAvg = (1 - doubleHit) * dpsSingle + doubleHit * (dpsSingle + dpsSingle); // double hit
    let dpsPerSecond = dpsAvg * (1 + atkSpeed / 100) * BASE_ATTACKS_PER_SECOND;

    // Lifesteal
    let lifeStealPerSecond = dpsPerSecond * lifeSteal;

    // Regen prend en compte le HP total (bonus inclus)
    let regenPerSecond = maxHp * regen;

    // Score global pondéré
    // ⚡ On ajoute contribution du block: chaque % de block vaut 50% du HP max
    let score = dpsPerSecond + lifeStealPerSecond * 1.5 + regenPerSecond + blockChance * maxHp * 0.5;

    return {score, dpsPerSecond, lifeStealPerSecond, regenPerSecond};
}




	let playerStats = computeScore(damage, attackSpeed, doubleHitChance, critChance, critDamageBonus, lifeSteal, regen, maxHP, damageBonus, meleeDamageBonus, blockChance);

    let bestScore = 0;
    let bestConfig = null;

	function generateConfigs(points, config = [0,0,0,0,0,0,0,0,0,0], index = 0) {
		if(index === config.length - 1) {
			config[index] = points;
			evaluateConfig(config);
			return;
		}
		for(let i=0; i<=points; i++){
			config[index] = i;
			generateConfigs(points - i, config, index + 1);
		}
	}

function evaluateConfig(cfg){
    // Limite par bonus
    for(let i=0;i<cfg.length;i++) cfg[i] = Math.min(cfg[i],12);

    let atkSpeed = Math.min(0.4 * cfg[0] * 100, CAPS.attackSpeed);
    let dblHit = Math.min(0.4 * cfg[1], CAPS.doubleHit);
    let ls = Math.min(0.2 * cfg[2], CAPS.lifeSteal);
    let critC = Math.min(0.12 * cfg[3], CAPS.critChance);
    let critD = Math.min(1.2 + cfg[4], CAPS.critDamage);
    let reg = Math.min(0.06 * cfg[5], CAPS.regen);
    let dmgBonus = Math.min(1 + 0.15 * cfg[6], CAPS.damage);

    // ✅ Calcul du bonus melee pour le score
// ✅ Calcul du bonus melee pour le score selon type d'arme
let meleeBonus = 1;
if(bestBuildWeaponType === "Melee") {
    meleeBonus = Math.min(1 + 0.5 * cfg[7], CAPS.meleeDamage);
}

    let block = Math.min(0.05 * cfg[8], CAPS.block);

    // HP
    let hpBonusMultiplier = 1 + 0.15 * cfg[9];
    let effectiveHP = hp * hpBonusMultiplier * hpMultiplier;

    // --- Block ajouté dans le score ---
    let stats = computeScore(
        damage,
        atkSpeed,
        dblHit,
        critC,
        critD,
        ls,
        reg,
        hp,
        dmgBonus,
        meleeBonus
    );

    // Ajouter contribution du block au score (simple poids)
    stats.score += block * hp * 0.5;  // chaque % de block vaut 0.5*base HP

    if(stats.score > bestScore){
        bestScore = stats.score;
        bestConfig = cfg.slice();
    }
}




    generateConfigs(totalBonusPoints);

	let bAtkSpeed = bestConfig[0] * 40;
	let bDouble = Math.min(1, bestConfig[1] * 0.4);
	let bLifeSteal = bestConfig[2] * 0.2;
	let bCritChance = 0.12 * bestConfig[3];
	let bCritDamage = 1.2 + bestConfig[4];
	let bRegen = 0.06 * bestConfig[5];
	let bDamageBonus = 1 + 0.15 * bestConfig[6];
	
	
// Sélection du type de weapon du best build indépendamment du joueur
let bestWeaponOptions = [];
let bestBuildChoice = bestBuildWeaponType; // Auto / Ranged / Melee

if(bestBuildChoice === "Auto"){
    bestWeaponOptions = ["Ranged", "Melee"];
} else {
    bestWeaponOptions = [bestBuildChoice];
}

let bestScoreWithWeapon = 0;
let bestWeaponTypeChosen = bestWeaponOptions[0];
let bestMeleeBonusChosen = 1;

bestWeaponOptions.forEach(bestWeapon => {
    let meleeBonus = (bestWeapon === "Melee") ? Math.min(1 + 0.5 * bestConfig[7], CAPS.meleeDamage) : 1;

    let stats = computeScore(
        damage,
        bAtkSpeed,
        bDouble,
        bCritChance,
        bCritDamage,
        bLifeSteal,
        bRegen,
        hp,
        bDamageBonus,
        meleeBonus
    );

    if(stats.score > bestScoreWithWeapon){
        bestScoreWithWeapon = stats.score;
        bestWeaponTypeChosen = bestWeapon;
        bestMeleeBonusChosen = meleeBonus;
    }
});



let bMelee = bestMeleeBonusChosen;
let bBlock = Math.min(0.05 * bestConfig[8], CAPS.block);
let bHP = 1 + 0.15 * bestConfig[9];
let bestMaxHP = hp * bHP * hpMultiplier;

// ⚡️ Assignation finale
let battleBestWeaponType;
battleBestWeaponType = bestWeaponTypeChosen;

let bestStats = computeScore(damage, bAtkSpeed, bDouble, bCritChance, bCritDamage, bLifeSteal, bRegen, bestMaxHP, bDamageBonus, bMelee, bBlock);



    let bestScoreNote = 100;
    let playerScoreNote = Math.round((playerStats.score / bestStats.score) * 100);

// Calculer le total réel des sub-stats du joueur
let playerSubStatsTotal = bonusAttackSpeed + bonusDoubleHit + bonusLifeSteal + bonusCritChance + bonusCritDamage + bonusRegen + bonusDamage + bonusMeleeDamage + bonusBlock + bonusHP;

document.getElementById('result').innerHTML = `
    <strong>Player Build (${playerSubStatsTotal} sub-stats):</strong><br>
    Average DPS: ${playerStats.dpsPerSecond.toFixed(2)}<br>
    Average Lifesteal per second: ${playerStats.lifeStealPerSecond.toFixed(2)}<br>
    Average Health Regen: ${playerStats.regenPerSecond.toFixed(2)}<br><br>
    Attack Speed: ${(bonusAttackSpeed > 0 ? (bonusAttackSpeed*40).toFixed(2) : 0)}% (${bonusAttackSpeed} pts)<br>
    Double Chance: ${(doubleHitChance*100).toFixed(2)}% (${bonusDoubleHit} pts)<br>
    Lifesteal: ${(lifeSteal*100).toFixed(2)}% (${bonusLifeSteal} pts)<br>
    Critical Chance: ${(critChance*100).toFixed(2)}% (${bonusCritChance} pts)<br>
    Critical Damage: ${(critDamageBonus*100).toFixed(2)}% (${bonusCritDamage} pts)<br>
    Health Regen: ${(regen*100).toFixed(2)}% (${bonusRegen} pts)<br>
    Damage: ${(bonusDamage > 0 ? (bonusDamage*15).toFixed(2) : 0)}% (${bonusDamage} pts)<br>
	Melee Damage: ${(weaponType === "Melee" && bonusMeleeDamage > 0 ? (bonusMeleeDamage*50).toFixed(2) : 0)}% (${bonusMeleeDamage} pts)<br>
	Block Chance: ${(blockChance*100).toFixed(2)}% (${bonusBlock} pts)<br>
    HP: ${(bonusHP > 0 ? (bonusHP*15).toFixed(2) : 0)}% (${bonusHP} pts)<br>
	
    <!--<strong>Overall Score:</strong> ${playerScoreNote}/100-->
`;


document.getElementById('bestBuild').innerHTML = `
    <strong>Best Build (${totalBonusPoints} sub-stats):</strong><br>
    Average DPS: ${bestStats.dpsPerSecond.toFixed(2)}<br>
    Average Lifesteal per second: ${bestStats.lifeStealPerSecond.toFixed(2)}<br>
    Average Health Regen: ${bestStats.regenPerSecond.toFixed(2)}<br><br>
    Attack Speed: ${(bestConfig[0] > 0 ? (bestConfig[0]*40).toFixed(2) : 0)}% (${bestConfig[0]} pts)<br>
    Double Chance: ${(bDouble*100).toFixed(2)}% (${bestConfig[1]} pts)<br>
    Lifesteal: ${(bLifeSteal*100).toFixed(2)}% (${bestConfig[2]} pts)<br>
    Critical Chance: ${(bCritChance*100).toFixed(2)}% (${bestConfig[3]} pts)<br>
    Critical Damage: ${(bCritDamage*100).toFixed(2)}% (${bestConfig[4]} pts)<br>
    Health Regen: ${(bRegen*100).toFixed(2)}% (${bestConfig[5]} pts)<br>
    Damage: ${(bestConfig[6] > 0 ? (bestConfig[6]*15).toFixed(2) : 0)}% (${bestConfig[6]} pts)<br>
	Melee Damage: ${((bMelee - 1) * 100).toFixed(2)}% (${bestConfig[7]} pts)<br>
	Block Chance: ${(bBlock * 100).toFixed(2)}% (${bestConfig[8]} pts)<br>
	HP: ${(bestConfig[9] > 0 ? (bestConfig[9]*15).toFixed(2) : 0)}% (${bestConfig[9]} pts)<br>
    <!--<strong>Overall Score:</strong> ${playerScoreNote}/100-->
`;


const canvasContainer = document.getElementById('canvasContainer');
canvasContainer.innerHTML = ''; // reset anciens combats

const canvases = [];

for(let i = 0; i < numSimulations; i++){
    const canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 300;
    canvasContainer.appendChild(canvas);
    canvases.push(canvas);
}

canvases.forEach((canvas, index) => {
    canvas.style.display = index < visibleSimulations ? 'block' : 'none';
});






const contexts = canvases.map(c => c.getContext('2d'));
let playerWins = 0;
let bestWins = 0;


function updateBattleScores() {
    let totalBattles = playerWins + bestWins;
    let winrate = totalBattles > 0 ? ((playerWins / totalBattles) * 100).toFixed(2) : 0;
    document.getElementById('battleScores').innerText = 
        `Player Wins: ${playerWins} | Best Build Wins: ${bestWins} | Player Winrate: ${winrate}%`;
}



let battles = contexts.map(() => ({
	player: {
		x: 100, y: 200, hp: hp*hpMultiplier, maxHp: hp*hpMultiplier, baseHp: hp,
		atkSpeed: attackSpeed, dbl: doubleHitChance, crit: critChance, critD: critDamageBonus,
		ls: lifeSteal, regen: regen, dmg: damage, dmgBonus: damageBonus,
		meleeDamageBonus: meleeDamageBonus,
		blockChance: blockChance,
		weaponType: weaponType,
		meleeSpeed: 0,
		firstMeleeHitDone: false
	},

	best: {
		x: 500, y: 200,
		hp: bestMaxHP,
		maxHp: bestMaxHP,
		baseHp: hp,

		atkSpeed: bAtkSpeed,
		dbl: bDouble,
		crit: bCritChance,
		critD: bCritDamage,
		ls: bLifeSteal,
		regen: bRegen,
		dmg: damage,
		dmgBonus: bDamageBonus,

		meleeDamageBonus: bMelee,
		blockChance: bBlock,

		weaponType: battleBestWeaponType, // maintenant le bot peut être Ranged ou Melee
		speed: 0,
		firstMeleeHitDone: false

	},

    messages: [],
    projectiles: [],
    lastRegen: 0,
    lastTime: 0,
    playerTimer: 0,
    bestTimer: 0,
}));





function draw(ctx, battle) {
    const { player, best, messages, projectiles } = battle;

    // Fond noir
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, 600, 300);

    // Joueur vert
    ctx.fillStyle='green';
    ctx.fillRect(player.x-20, player.y-20, 40, 40);
    ctx.fillStyle='red';
    ctx.fillRect(player.x-25, player.y-30, 50*(player.hp/player.maxHp), 5);

    // Best bleu
    ctx.fillStyle='blue';
    ctx.fillRect(best.x-20, best.y-20, 40,40);
    ctx.fillStyle='red';
    ctx.fillRect(best.x-25, best.y-30, 50*(best.hp/best.maxHp),5);

    // Messages
    for(let i=0;i<messages.length;i++){
        ctx.font='bold 16px Arial';
        ctx.fillStyle=messages[i].color;
        ctx.fillText(messages[i].text, messages[i].x, messages[i].y);
        messages[i].y -= 0.5;
        messages[i].alpha -= 0.003;
    }
    battle.messages = messages.filter(m=>m.alpha>0);

    // Projectiles
    for(let i=0;i<projectiles.length;i++){
        ctx.fillStyle = projectiles[i].color;
        ctx.beginPath();
        ctx.arc(projectiles[i].x, projectiles[i].y, 5, 0, 2*Math.PI);
        ctx.fill();
        projectiles[i].x += projectiles[i].vx;
        projectiles[i].y += projectiles[i].vy;
    }
    battle.projectiles = projectiles.filter(p => !p.hit && p.x>0 && p.x<600);
}




function attack(attacker, defender, battle){
	// Si l'attaquant est Melee, attaque directe
// Si l'attaquant est Melee, attaque directe
if(attacker.weaponType === "Melee") {
    // Vérifier la distance minimale pour attaquer
    let dx = defender.x - attacker.x;
    let dy = defender.y - attacker.y;
    let distance = Math.sqrt(dx*dx + dy*dy);
    if(distance > MELEE_MIN_DISTANCE) return;

    // Nombre de hits selon doubleHitChance
    let hits = 1;
    if(Math.random() < attacker.dbl) hits = 2;

    for(let i=0; i<hits; i++) {
        let isCrit = Math.random() < attacker.crit;
        let dmgBase = attacker.dmg * attacker.dmgBonus;
        if(attacker.weaponType === "Melee" && attacker.meleeDamageBonus) dmgBase *= attacker.meleeDamageBonus;
        let dmg = Math.floor(isCrit ? dmgBase * attacker.critD : dmgBase);

        // Blocage
        if(Math.random() < defender.blockChance) {
            battle.messages.push({
                x: defender.x - 10,
                y: defender.y - 25 - i*15, // ← chaque hit a son propre décalage
                text: 'BLOCK',
                color: 'violet',
                alpha: 1
            });
            continue; // attaqué mais bloqué
        }

        defender.hp -= dmg;

        // Message dégâts séparé pour chaque hit
        battle.messages.push({
            x: defender.x - 10,
            y: defender.y - 25 - i*15, // ← chaque hit a son propre décalage
            text: '-' + dmg,
            color: isCrit ? 'red' : 'orange',
            alpha: 1
        });

        // Lifesteal séparé pour chaque hit
        if(attacker.ls > 0) {
            let heal = Math.floor(dmg * attacker.ls);
            attacker.hp = Math.min(attacker.maxHp, attacker.hp + heal);
            battle.messages.push({
                x: attacker.x - 10,
                y: attacker.y - 45 - i*15, // ← décalage propre à chaque hit
                text: '+ ' + heal,
                color: 'green',
                alpha: 1
            });
        }
    }

    return; // pas besoin de projectiles
}

    let hits = 1;
    if(Math.random() < attacker.dbl) hits = 2;

    let baseDx = defender.x - attacker.x;
    let baseDy = defender.y - attacker.y;
    let baseDist = Math.sqrt(baseDx*baseDx + baseDy*baseDy);
    let dirX = baseDx / baseDist;
    let dirY = baseDy / baseDist;

    for(let i=0;i<hits;i++){
        let offsetX = 0;
        let offsetY = 0;
        if(hits === 2){
            let separation = (i === 0 ? -10 : 120);
            offsetX = dirX * separation;
            offsetY = dirY * separation;
        }
        let dx = defender.x - (attacker.x + offsetX);
        let dy = defender.y - (attacker.y + offsetY);
        let dist = Math.sqrt(dx*dx + dy*dy);
        let vx = dx / dist * 5;
        let vy = dy / dist * 5;

        battle.projectiles.push({
            x: attacker.x + offsetX,
            y: attacker.y + offsetY,
            vx: vx,
            vy: vy,
            color: 'orange',
            dmg: attacker.dmg * attacker.dmgBonus,
            attacker: attacker,
            target: defender,
            hit: false
        });
    }
}



function hitProjectiles(battle){
    battle.projectiles.forEach(p=>{
        let dx = Math.abs(p.x - p.target.x);
        let dy = Math.abs(p.y - p.target.y);
        if(dx<5 && dy<5){
            let isCrit = Math.random() < p.attacker.crit;
            let dmgBase = p.dmg;
            let dmg = Math.floor(isCrit ? dmgBase * p.attacker.critD : dmgBase);

            // Générer un offset vertical pour ce hit, qu'il soit bloqué ou non
            let offsetY = (p.attacker.dbl > 0) ? (-15 + Math.random() * 10) : 0;

            if(Math.random() < p.target.blockChance){
                battle.messages.push({
                    x: p.target.x - 10,
                    y: p.target.y - 25 + offsetY, // ← même décalage que pour le hit normal
                    text: 'BLOCK',
                    color: 'violet',
                    alpha: 1
                });
            } else {
                p.target.hp -= dmg;

                battle.messages.push({
                    x: p.target.x - 10,
                    y: p.target.y - 25 + offsetY,
                    text:'-'+dmg,
                    color:isCrit?'red':'orange',
                    alpha:1
                });
            }

            if (p.attacker.ls > 0) {
                let healPotential = Math.floor(dmg * p.attacker.ls);
                let healReal = Math.max(0, Math.min(healPotential, p.attacker.maxHp - p.attacker.hp));
                p.attacker.hp += healReal;

                battle.messages.push({
                    x: p.attacker.x - 10,
                    y: p.attacker.y - 45 + offsetY,
                    text: '+ ' + healReal,
                    color: 'green',
                    alpha: 1
                });
            }

            p.hit=true;
        }
    });
}


let lastTime = 0;
let playerTimer = 0;
let bestTimer = 0;
let firstAttackDone = false;

function loop(timestamp, ctx, battle, simId) {
	if(simId !== simulationId) return;
    if(!battle.lastTime) battle.lastTime = timestamp;
    let dt = timestamp - battle.lastTime;
    battle.lastTime = timestamp;

    battle.playerTimer += dt;
    battle.bestTimer += dt;
    battle.lastRegen += dt;


			if(battle.player.weaponType === "Melee"){
				let dx = battle.best.x - battle.player.x;
				let dy = battle.best.y - battle.player.y;
				let distance = Math.sqrt(dx*dx + dy*dy);

				if(distance > MELEE_MIN_DISTANCE){
					battle.player.x += (dx / distance) * battle.player.meleeSpeed * dt;
					battle.player.y += (dy / distance) * battle.player.meleeSpeed * dt;
				} else if(!battle.player.firstMeleeHitDone){
					// ⚡ attaque instantanée à l'arrivée
					attack(battle.player, battle.best, battle);
					battle.player.firstMeleeHitDone = true;
					battle.playerTimer = 0;
				}
			}



			if(battle.best.weaponType === "Melee"){
				let dx = battle.player.x - battle.best.x;
				let dy = battle.player.y - battle.best.y;
				let distance = Math.sqrt(dx*dx + dy*dy);

				if(distance > MELEE_MIN_DISTANCE){
					battle.best.x += (dx / distance) * battle.best.meleeSpeed * dt;
					battle.best.y += (dy / distance) * battle.best.meleeSpeed * dt;
				} else if(!battle.best.firstMeleeHitDone){
					// ⚡ attaque instantanée à l'arrivée
					attack(battle.best, battle.player, battle);
					battle.best.firstMeleeHitDone = true;
					battle.bestTimer = 0;
				}
			}




        let playerInterval = 1000 / (1/1.7*(1+battle.player.atkSpeed/100));
        let bestInterval = 1000 / (1/1.7*(1+battle.best.atkSpeed/100));

		if(battle.playerTimer >= playerInterval){
			if(
				battle.player.weaponType !== "Melee" ||
				Math.hypot(
					battle.best.x - battle.player.x,
					battle.best.y - battle.player.y
				) <= MELEE_MIN_DISTANCE
			){
				attack(battle.player, battle.best, battle);
				battle.playerTimer -= playerInterval;
			}
		}

		if(battle.bestTimer >= bestInterval){
			if(
				battle.best.weaponType !== "Melee" ||
				Math.hypot(
					battle.player.x - battle.best.x,
					battle.player.y - battle.best.y
				) <= MELEE_MIN_DISTANCE
			){
				attack(battle.best, battle.player, battle);
				battle.bestTimer -= bestInterval;
			}
		}


    if(battle.lastRegen>=1000){
        [battle.player,battle.best].forEach(unit=>{
            if(unit.regen>0){
                let healPotential = Math.floor(unit.baseHp * unit.regen);
                let healReal = Math.max(0, Math.min(healPotential, unit.maxHp - unit.hp));
                unit.hp += healReal;
                battle.messages.push({x: unit.x-10, y: unit.y-45, text:'+ '+healReal, color:'green', alpha:1});
            }
        });
        battle.lastRegen=0;
    }

    hitProjectiles(battle);
    draw(ctx, battle);

	if(battle.player.hp <= 0 || battle.best.hp <= 0){
		ctx.font='bold 24px Arial';
		ctx.fillStyle='yellow';
		
		let winner = battle.player.hp <= 0 ? 'Best build' : 'Player';
		ctx.fillText(winner + ' wins!', 200, 150);

		// ✅ Mettre à jour les scores
		if(battle.player.hp <= 0) bestWins++;
		else playerWins++;

		updateBattleScores();

	} else {
		requestAnimationFrame(ts => loop(ts, ctx, battle, simId));
	}

}

battles.forEach((battle) => {
    // calcul de la distance initiale entre les deux
    let dx = battle.best.x - battle.player.x;
    let dy = battle.best.y - battle.player.y;
    let initialDistance = Math.sqrt(dx*dx + dy*dy) - MELEE_MIN_DISTANCE;

    let bothMelee = (battle.player.weaponType === "Melee" && battle.best.weaponType === "Melee");

    // Vitesse du joueur
    if(battle.player.weaponType === "Melee") {
        let distanceToCover = bothMelee ? initialDistance / 2 : initialDistance;
        battle.player.meleeSpeed = distanceToCover / (MELEE_APPROACH_TIME * 1000); // pixels/ms
    } else {
        battle.player.meleeSpeed = 0;
    }

    // Vitesse du best build
    if(battle.best.weaponType === "Melee") {
        let distanceToCover = bothMelee ? initialDistance / 2 : initialDistance;
        battle.best.meleeSpeed = distanceToCover / (MELEE_APPROACH_TIME * 1000); // pixels/ms
    } else {
        battle.best.meleeSpeed = 0;
    }
});


battles.forEach((battle, i) => {
    requestAnimationFrame(ts => loop(ts, contexts[i], battle, currentSimulationId));
});



updateBattleScores();

updateURL();
}


window.onload = () => {
    loadFromURL();
    calculate();
};

</script>
</body>
</html>
