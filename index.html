<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Battle Simulator Forge Master</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; background-color: #f0f0f0; }
.container { background: #fff; padding: 20px; border-radius: 10px; max-width: 600px; margin: auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
label { display: block; margin-top: 10px; }
input[type=number] { width: 60px; }
button { margin-top: 20px; padding: 10px 15px; font-size: 16px; }
.result { margin-top: 20px; background: #e0ffe0; padding: 10px; border-radius: 5px; }
.best-build { margin-top: 20px; background: #c0dfff; padding: 10px; border-radius: 5px; }
.canvas-container {
    display: flex;
    flex-wrap: wrap;          /* permet de passer à la ligne suivante */
    gap: 20px;                /* espace entre canvas */
    justify-content: center;  /* centre horizontalement */
    padding: 20px;
    background-color: #f8f8f8; /* léger fond pour différencier */
    width: 100%;              /* prend toute la largeur */
    box-sizing: border-box;
}

.canvas-container canvas {
    border-radius: 10px;
    background-color: #222;
}




</style>
</head>
<body>
<div class="container">
<h2>Battle Simulator Forge Master</h2>
<label>Base Damage: <input type="number" id="damage" value="30000"></label>
<label>Base HP: <input type="number" id="hp" value="200000"></label>
<label>PvP HP multiplier: <input type="number" id="hpMultiplier" value="5"></label>
<label>Total number of Sub-stats assigned to create the "Best Build": <input type="number" id="bonusPoints" value="12"></label>
<h3>Distribute your sub-stats:</h3>
<label>Attack Speed (+40% per sub-stat): <input type="number" id="bonusAttackSpeed" value="2"></label>
<label>Double Chance (+40% per sub-stat): <input type="number" id="bonusDoubleHit" value="2"></label>
<label>Lifesteal (+20% per sub-stat): <input type="number" id="bonusLifeSteal" value="2"></label>
<label>Critical Chance (+12% per sub-stat): <input type="number" id="bonusCritChance" value="2"></label>
<label>Critical Damage (+100% per sub-stat): <input type="number" id="bonusCritDamage" value="2"></label>
<label>Health Regen (+6% per sub-stat): <input type="number" id="bonusRegen" value="1"></label>
<label>Damage (+15% per sub-stat): <input type="number" id="bonusDamage" value="1"></label>
<button onclick="calculate()">Calculate and Start Battle</button>
<div class="result" id="result"></div>
<div class="best-build" id="bestBuild"></div>
</div>

<div class="canvas-container">
	<canvas id="battleCanvas1" width="600" height="300"></canvas>
	<canvas id="battleCanvas2" width="600" height="300"></canvas>
	<canvas id="battleCanvas3" width="600" height="300"></canvas>
	<canvas id="battleCanvas4" width="600" height="300"></canvas>
	<canvas id="battleCanvas5" width="600" height="300"></canvas>
	<canvas id="battleCanvas6" width="600" height="300"></canvas>
	<canvas id="battleCanvas7" width="600" height="300"></canvas>
	<canvas id="battleCanvas8" width="600" height="300"></canvas>
	<canvas id="battleCanvas9" width="600" height="300"></canvas>
</div>

<script>

function updateURL() {
    const fields = [
        'damage', 'hp', 'hpMultiplier', 'bonusPoints',
        'bonusAttackSpeed', 'bonusDoubleHit', 'bonusLifeSteal',
        'bonusCritChance', 'bonusCritDamage', 'bonusRegen', 'bonusDamage'
    ];

    const params = new URLSearchParams();

    fields.forEach(id => {
        params.set(id, document.getElementById(id).value);
    });

    const newURL = window.location.origin + window.location.pathname + '?' + params.toString();
    window.history.replaceState({}, '', newURL); // Met à jour l’URL sans recharger la page
}

function loadFromURL() {
    const params = new URLSearchParams(window.location.search);
    const fields = [
        'damage', 'hp', 'hpMultiplier', 'bonusPoints',
        'bonusAttackSpeed', 'bonusDoubleHit', 'bonusLifeSteal',
        'bonusCritChance', 'bonusCritDamage', 'bonusRegen', 'bonusDamage'
    ];

    fields.forEach(id => {
        if(params.has(id)) {
            document.getElementById(id).value = params.get(id);
        }
    });
}


function calculate() {
    const BASE_ATTACKS_PER_SECOND = 1 / 1.7;

    let damage = parseFloat(document.getElementById('damage').value);
    let hp = parseFloat(document.getElementById('hp').value);
    let hpMultiplier = parseFloat(document.getElementById('hpMultiplier').value) || 1;
    let totalBonusPoints = parseInt(document.getElementById('bonusPoints').value);

    let bonusAttackSpeed = parseInt(document.getElementById('bonusAttackSpeed').value) || 0;
    let bonusDoubleHit = parseInt(document.getElementById('bonusDoubleHit').value) || 0;
    let bonusLifeSteal = parseInt(document.getElementById('bonusLifeSteal').value) || 0;
    let bonusCritChance = parseInt(document.getElementById('bonusCritChance').value) || 0;
    let bonusCritDamage = parseInt(document.getElementById('bonusCritDamage').value) || 0;
    let bonusRegen = parseInt(document.getElementById('bonusRegen').value) || 0;
    let bonusDamage = parseInt(document.getElementById('bonusDamage').value) || 0;

    let attackSpeed = 0.4 * bonusAttackSpeed * 100;
    let doubleHitChance = Math.min(1, 0.4 * bonusDoubleHit);
    let lifeSteal = 0.2 * bonusLifeSteal;
    let critChance = 0.12 * bonusCritChance;
    let critDamageBonus = 1.2 + 1.0 * bonusCritDamage;
    let regen = 0.06 * bonusRegen;
    let damageBonus = 1 + 0.15 * bonusDamage;

    function computeScore(damage, atkSpeed, doubleHit, critChance, critDamage, lifeSteal, regen, hp, dmgBonus) {
        let dpsSingle = damage * dmgBonus * (1 + critChance * (critDamage - 1));
        let dpsAvg = (1 - doubleHit) * dpsSingle + doubleHit * (dpsSingle + damage * dmgBonus * (1 + critChance * (critDamage - 1)));
        let dpsPerSecond = dpsAvg * (1 + atkSpeed / 100) * BASE_ATTACKS_PER_SECOND;
        let lifeStealPerSecond = dpsPerSecond * lifeSteal;
        let regenPerSecond = hp * regen;
        let score = dpsPerSecond + (lifeStealPerSecond * 1.5) + regenPerSecond;
        return {score, dpsPerSecond, lifeStealPerSecond, regenPerSecond};
    }

    let playerStats = computeScore(damage, attackSpeed, doubleHitChance, critChance, critDamageBonus, lifeSteal, regen, hp, damageBonus);

    let bestScore = 0;
    let bestConfig = null;

    function generateConfigs(points, config = [0,0,0,0,0,0,0], index = 0) {
        if(index === config.length - 1) {
            config[index] = points;
            evaluateConfig(config);
            return;
        }
        for(let i=0; i<=points; i++){
            config[index] = i;
            generateConfigs(points - i, config, index + 1);
        }
    }

    function evaluateConfig(cfg){
        let atkSpeed = 0.4 * cfg[0] * 100;
        let dblHit = Math.min(1, 0.4 * cfg[1]);
        let ls = 0.2 * cfg[2];
        let critC = 0.12 * cfg[3];
        let critD = 1.2 + cfg[4];
        let reg = 0.06 * cfg[5];
        let dmgBonus = 1 + 0.15 * cfg[6];

        let stats = computeScore(damage, atkSpeed, dblHit, critC, critD, ls, reg, hp, dmgBonus);

        if(stats.score > bestScore){
            bestScore = stats.score;
            bestConfig = cfg.slice();
        }
    }

    generateConfigs(totalBonusPoints);

    let bAtkSpeed = bestConfig[0] * 40;
    let bDouble = Math.min(1, bestConfig[1] * 0.4);
    let bLifeSteal = bestConfig[2] * 0.2;
    let bCritChance = 0.12 * bestConfig[3];
    let bCritDamage = 1.2 + bestConfig[4];
    let bRegen = 0.06 * bestConfig[5];
    let bDamageBonus = 1 + 0.15 * bestConfig[6];

    let bestStats = computeScore(damage, bAtkSpeed, bDouble, bCritChance, bCritDamage, bLifeSteal, bRegen, hp, bDamageBonus);

    let bestScoreNote = 100;
    let playerScoreNote = Math.round((playerStats.score / bestStats.score) * 100);

// Calculer le total réel des sub-stats du joueur
let playerSubStatsTotal = bonusAttackSpeed + bonusDoubleHit + bonusLifeSteal + bonusCritChance + bonusCritDamage + bonusRegen + bonusDamage;

document.getElementById('result').innerHTML = `
    <strong>Player Build (${playerSubStatsTotal} sub-stats):</strong><br>
    Average DPS: ${playerStats.dpsPerSecond.toFixed(2)}<br>
    Average Lifesteal per second: ${playerStats.lifeStealPerSecond.toFixed(2)}<br>
    Average Health Regen: ${playerStats.regenPerSecond.toFixed(2)}<br><br>
    Attack Speed: ${attackSpeed.toFixed(2)}% (${bonusAttackSpeed} pts)<br>
    Double Chance: ${(doubleHitChance*100).toFixed(2)}% (${bonusDoubleHit} pts)<br>
    Lifesteal: ${(lifeSteal*100).toFixed(2)}% (${bonusLifeSteal} pts)<br>
    Critical Chance: ${(critChance*100).toFixed(2)}% (${bonusCritChance} pts)<br>
    Critical Damage: ${(critDamageBonus*100).toFixed(2)}% (${bonusCritDamage} pts)<br>
    Health Regen: ${(regen*100).toFixed(2)}% (${bonusRegen} pts)<br>
    Damage Bonus: ${(bonusDamage*15).toFixed(2)}% (${bonusDamage} pts)<br><br>
    <strong>Overall Score:</strong> ${playerScoreNote}/100
`;

document.getElementById('bestBuild').innerHTML = `
    <strong>Best Build (${totalBonusPoints} sub-stats):</strong><br>
    Average DPS: ${bestStats.dpsPerSecond.toFixed(2)}<br>
    Average Lifesteal per second: ${bestStats.lifeStealPerSecond.toFixed(2)}<br>
    Average Health Regen: ${bestStats.regenPerSecond.toFixed(2)}<br><br>
    Attack Speed: ${bAtkSpeed.toFixed(2)}% (${bestConfig[0]} pts)<br>
    Double Chance: ${(bDouble*100).toFixed(2)}% (${bestConfig[1]} pts)<br>
    Lifesteal: ${(bLifeSteal*100).toFixed(2)}% (${bestConfig[2]} pts)<br>
    Critical Chance: ${(bCritChance*100).toFixed(2)}% (${bestConfig[3]} pts)<br>
    Critical Damage: ${(bCritDamage*100).toFixed(2)}% (${bestConfig[4]} pts)<br>
    Health Regen: ${(bRegen*100).toFixed(2)}% (${bestConfig[5]} pts)<br>
    Damage Bonus: ${(bestConfig[6]*15).toFixed(2)}% (${bestConfig[6]} pts)<br><br>
    <strong>Overall Score:</strong> ${bestScoreNote}/100
`;

const canvases = [];
for(let i = 1; i <= 9; i++){
    canvases.push(document.getElementById(`battleCanvas${i}`));
}


const contexts = canvases.map(c => c.getContext('2d'));

let battles = contexts.map(() => ({
    player: {x:100, y:200, hp:hp*hpMultiplier, maxHp:hp*hpMultiplier, baseHp:hp, atkSpeed:attackSpeed, dbl:doubleHitChance, crit:critChance, critD:critDamageBonus, ls:lifeSteal, regen:regen, dmg:damage, dmgBonus:damageBonus},
    best: {x:500, y:200, hp:hp*hpMultiplier, maxHp:hp*hpMultiplier, baseHp:hp, atkSpeed:bAtkSpeed, dbl:bDouble, crit:bCritChance, critD:bCritDamage, ls:bLifeSteal, regen:bRegen, dmg:damage, dmgBonus:bDamageBonus},
    messages: [],
    projectiles: [],
    lastRegen: 0,
    lastTime: 0,
    playerTimer: 0,
    bestTimer: 0,
    firstAttackDone: false
}));




function draw(ctx, battle) {
    const { player, best, messages, projectiles } = battle;

    // Fond noir
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, 600, 300);

    // Joueur vert
    ctx.fillStyle='green';
    ctx.fillRect(player.x-20, player.y-20, 40, 40);
    ctx.fillStyle='red';
    ctx.fillRect(player.x-25, player.y-30, 50*(player.hp/player.maxHp), 5);

    // Best bleu
    ctx.fillStyle='blue';
    ctx.fillRect(best.x-20, best.y-20, 40,40);
    ctx.fillStyle='red';
    ctx.fillRect(best.x-25, best.y-30, 50*(best.hp/best.maxHp),5);

    // Messages
    for(let i=0;i<messages.length;i++){
        ctx.font='bold 16px Arial';
        ctx.fillStyle=messages[i].color;
        ctx.fillText(messages[i].text, messages[i].x, messages[i].y);
        messages[i].y -= 0.5;
        messages[i].alpha -= 0.003;
    }
    battle.messages = messages.filter(m=>m.alpha>0);

    // Projectiles
    for(let i=0;i<projectiles.length;i++){
        ctx.fillStyle = projectiles[i].color;
        ctx.beginPath();
        ctx.arc(projectiles[i].x, projectiles[i].y, 5, 0, 2*Math.PI);
        ctx.fill();
        projectiles[i].x += projectiles[i].vx;
        projectiles[i].y += projectiles[i].vy;
    }
    battle.projectiles = projectiles.filter(p => !p.hit && p.x>0 && p.x<600);
}




function attack(attacker, defender, battle){
    let hits = 1;
    if(Math.random() < attacker.dbl) hits = 2;

    let baseDx = defender.x - attacker.x;
    let baseDy = defender.y - attacker.y;
    let baseDist = Math.sqrt(baseDx*baseDx + baseDy*baseDy);
    let dirX = baseDx / baseDist;
    let dirY = baseDy / baseDist;

    for(let i=0;i<hits;i++){
        let offsetX = 0;
        let offsetY = 0;
        if(hits === 2){
            let separation = (i === 0 ? -10 : 120);
            offsetX = dirX * separation;
            offsetY = dirY * separation;
        }
        let dx = defender.x - (attacker.x + offsetX);
        let dy = defender.y - (attacker.y + offsetY);
        let dist = Math.sqrt(dx*dx + dy*dy);
        let vx = dx / dist * 5;
        let vy = dy / dist * 5;

        battle.projectiles.push({
            x: attacker.x + offsetX,
            y: attacker.y + offsetY,
            vx: vx,
            vy: vy,
            color: 'orange',
            dmg: attacker.dmg * attacker.dmgBonus,
            attacker: attacker,
            target: defender,
            hit: false
        });
    }
}



function hitProjectiles(battle){
    battle.projectiles.forEach(p=>{
        let dx = Math.abs(p.x - p.target.x);
        let dy = Math.abs(p.y - p.target.y);
        if(dx<5 && dy<5){
            let isCrit = Math.random() < p.attacker.crit;
            let dmg = Math.floor(isCrit ? p.dmg * p.attacker.critD : p.dmg);
            p.target.hp -= dmg;
            battle.messages.push({x:p.target.x-10, y:p.target.y-25, text:'-'+dmg, color:isCrit?'red':'orange', alpha:1});

            if (p.attacker.ls > 0) {
                let healPotential = Math.floor(dmg * p.attacker.ls);
                let healReal = Math.max(0, Math.min(healPotential, p.attacker.maxHp - p.attacker.hp));
                p.attacker.hp += healReal;
                battle.messages.push({x: p.attacker.x - 10, y: p.attacker.y - 45, text: '+ ' + healReal, color: 'green', alpha: 1});
            }

            p.hit=true;
        }
    });
}


let lastTime = 0;
let playerTimer = 0;
let bestTimer = 0;
let firstAttackDone = false;

function loop(timestamp, ctx, battle) {
    if(!battle.lastTime) battle.lastTime = timestamp;
    let dt = timestamp - battle.lastTime;
    battle.lastTime = timestamp;

    battle.playerTimer += dt;
    battle.bestTimer += dt;
    battle.lastRegen += dt;

    if(!battle.firstAttackDone) {
        attack(battle.player, battle.best, battle);
        attack(battle.best, battle.player, battle);
        battle.playerTimer = 0;
        battle.bestTimer = 0;
        battle.firstAttackDone = true;
    } else {
        let playerInterval = 1000 / (1/1.7*(1+battle.player.atkSpeed/100));
        let bestInterval = 1000 / (1/1.7*(1+battle.best.atkSpeed/100));

        if(battle.playerTimer >= playerInterval){ attack(battle.player, battle.best, battle); battle.playerTimer -= playerInterval; }
        if(battle.bestTimer >= bestInterval){ attack(battle.best, battle.player, battle); battle.bestTimer -= bestInterval; }
    }

    if(battle.lastRegen>=1000){
        [battle.player,battle.best].forEach(unit=>{
            if(unit.regen>0){
                let healPotential = Math.floor(unit.baseHp * unit.regen);
                let healReal = Math.max(0, Math.min(healPotential, unit.maxHp - unit.hp));
                unit.hp += healReal;
                battle.messages.push({x: unit.x-10, y: unit.y-45, text:'+ '+healReal, color:'green', alpha:1});
            }
        });
        battle.lastRegen=0;
    }

    hitProjectiles(battle);
    draw(ctx, battle);

    if(battle.player.hp<=0 || battle.best.hp<=0){
        ctx.font='bold 24px Arial';
        ctx.fillStyle='yellow';
        ctx.fillText(battle.player.hp<=0?'Best build wins!':'Player wins!',200,150);
    } else {
        requestAnimationFrame(ts => loop(ts, ctx, battle));
    }
}

battles.forEach((battle, i) => {
    requestAnimationFrame(ts => loop(ts, contexts[i], battle));
});



updateURL();
}


window.onload = () => {
    loadFromURL();
    calculate();
};

</script>
</body>
</html>
